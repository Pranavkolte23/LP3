1st


#include <iostream>
using namespace std;

// Recursive Fibonacci Function
int fibonacciRecursive(int n) {
    if (n <= 1)
        return n;   // Base cases: F(0)=0, F(1)=1
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}

// Non-Recursive (Iterative) Fibonacci Function
void fibonacciIterative(int n) {
    int a = 0, b = 1, c;

    cout << "Fibonacci Series (Iterative): ";
    if (n >= 1)
        cout << a << " ";
    if (n >= 2)
        cout << b << " ";

    for (int i = 2; i < n; i++) {
        c = a + b;
        cout << c << " ";
        a = b;
        b = c;
    }
    cout << endl;
}

// Menu-driven main program
int main() {
    int choice, n;

    do {
        cout << "\n===== Fibonacci Menu =====";
        cout << "\n1. Recursive Fibonacci";
        cout << "\n2. Non-Recursive (Iterative) Fibonacci";
        cout << "\n3. Exit";
        cout << "\nEnter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter number of terms: ";
                cin >> n;
                cout << "Fibonacci Series (Recursive): ";
                for (int i = 0; i < n; i++)
                    cout << fibonacciRecursive(i) << " ";
                cout << endl;
                cout << "Time Complexity: O(2^n)\n";
                cout << "Space Complexity: O(n)\n";
                break;

            case 2:
                cout << "Enter number of terms: ";
                cin >> n;
                fibonacciIterative(n);
                cout << "Time Complexity: O(n)\n";
                cout << "Space Complexity: O(1)\n";
                break;

            case 3:
                cout << "Exiting program..." << endl;
                break;

            default:
                cout << "Invalid choice! Please try again.\n";
        }
    } while (choice != 3);

    return 0;
}

----------------------------------------------
#include <bits/stdc++.h>
using namespace std;

struct Node {
    char ch; int freq;
    Node *l, *r;
    Node(char c, int f) : ch(c), freq(f), l(NULL), r(NULL) {}
};

struct cmp { bool operator()(Node* a, Node* b){ return a->freq > b->freq; } };

void printCodes(Node* root, string s="") {
    if (!root) return;
    if (!root->l && !root->r) cout << root->ch << ": " << s << "\n";
    printCodes(root->l, s + "0");
    printCodes(root->r, s + "1");
}

int main() {
    vector<char> chars = {'a','b','c','d','e','f'};
    vector<int> freq = {5,9,12,13,16,45};
    priority_queue<Node*, vector<Node*>, cmp> pq;
    for (int i=0;i<chars.size();i++) pq.push(new Node(chars[i], freq[i]));
    while (pq.size() > 1) {
        Node *l = pq.top(); pq.pop();
        Node *r = pq.top(); pq.pop();
        Node *n = new Node('$', l->freq + r->freq);
        n->l = l; n->r = r;
        pq.push(n);
    }
    printCodes(pq.top());
}

--------------------------

#include <bits/stdc++.h>
using namespace std;

int main() {
    int n = 3, W = 50;
    int wt[] = {10, 20, 30};
    int val[] = {60, 100, 120};

    int dp[n + 1][W + 1];

    for (int i = 0; i <= n; i++)
        for (int w = 0; w <= W; w++)
            if (i == 0 || w == 0) dp[i][w] = 0;
            else if (wt[i - 1] <= w)
                dp[i][w] = max(val[i - 1] + dp[i - 1][w - wt[i - 1]], dp[i - 1][w]);
            else
                dp[i][w] = dp[i - 1][w];

    cout << "Maximum value = " << dp[n][W];
}

--------------------------------------
#include <bits/stdc++.h>
using namespace std;

int n; vector<vector<int>> board;

bool safe(int r, int c) {
    for (int i = 0; i < r; i++)
        if (board[i][c] || (c>=r-i && board[i][c-r+i]) || (c+r-i<n && board[i][c+r-i])) 
            return false;
    return true;
}

bool solve(int r=1) {
    if (r == n) return true;
    for (int c = 0; c < n; c++)
        if (safe(r, c)) {
            board[r][c] = 1;
            if (solve(r+1)) return true;
            board[r][c] = 0;
        }
    return false;
}

int main() {
    cin >> n;
    board.assign(n, vector<int>(n, 0));
    board[0][0] = 1; // first queen placed
    solve();
    for (auto &r : board) { for (int x : r) cout << x << " "; cout << "\n"; }
}

----------------------------------------
import random
import time

# ------------------- DETERMINISTIC QUICK SORT -------------------
def partition_deterministic(arr, low, high):
    pivot = arr[high]       # Last element as pivot
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1

def quicksort_deterministic(arr, low, high):
    if low < high:
        pi = partition_deterministic(arr, low, high)
        quicksort_deterministic(arr, low, pi - 1)
        quicksort_deterministic(arr, pi + 1, high)

# ------------------- RANDOMIZED QUICK SORT -------------------
def partition_randomized(arr, low, high):
    pivot_index = random.randint(low, high)  # random pivot
    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]  # swap with last
    return partition_deterministic(arr, low, high)

def quicksort_randomized(arr, low, high):
    if low < high:
        pi = partition_randomized(arr, low, high)
        quicksort_randomized(arr, low, pi - 1)
        quicksort_randomized(arr, pi + 1, high)

# ------------------- MAIN PROGRAM -------------------
def analyze_quicksort():
    n = int(input("Enter number of elements: "))
    arr = [int(x) for x in input("Enter elements: ").split()]
    
    arr1 = arr[:]   # copy for deterministic
    arr2 = arr[:]   # copy for randomized

    print("\nOriginal array:", arr)

    # Deterministic Quick Sort
    start = time.time()
    quicksort_deterministic(arr1, 0, n - 1)
    end = time.time()
    print("\nSorted array (Deterministic Quick Sort):", arr1)
    print("Time taken:", (end - start), "seconds")

    # Randomized Quick Sort
    start = time.time()
    quicksort_randomized(arr2, 0, n - 1)
    end = time.time()
    print("\nSorted array (Randomized Quick Sort):", arr2)
    print("Time taken:", (end - start), "seconds")

# Run Program
analyze_quicksort()

#20 2 7 12 15 1 6 8
-----------------------------------------------

BlockChain

1st------------------


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BankAccount {
    address public owner;
    uint public balance;

    constructor() {
        owner = msg.sender;
        balance = 0;
    }

    // Deposit money into the account
    function deposit() public payable {
        balance += msg.value;
    }

    // Withdraw money
    function withdraw(uint amount) public {
        require(msg.sender == owner, "Only owner can withdraw");
        require(amount <= balance, "Insufficient balance");
        payable(owner).transfer(amount);
        balance -= amount;
    }

    // Show balance
    function getBalance() public view returns (uint) {
        return balance;
    }
}



-----------------------------
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StudentData {
    struct Student {
        uint id;
        string name;
        uint marks;
    }

    Student[] public students;

    // Add new student
    function addStudent(uint _id, string memory _name, uint _marks) public {
        students.push(Student(_id, _name, _marks));
    }

    // Get student by index
    function getStudent(uint index) public view returns (uint, string memory, uint) {
        require(index < students.length, "Invalid index");
        Student memory s = students[index];
        return (s.id, s.name, s.marks);
    }

    // Get total students
    function totalStudents() public view returns (uint) {
        return students.length;
    }

    // Fallback and receive functions
    fallback() external payable {}
    receive() external payable {}
}




